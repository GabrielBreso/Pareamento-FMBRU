<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <title>Comparação de Respostas</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            color: #333;
            font-weight: 100;
        }

        header {
            padding: 3rem;
            background-color: #4CAF50;
            color: #fffdfd;
            text-align: center;
        }

        main {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            padding: 0;
        }

        main::before {
            content: '';
            position: absolute;
            padding: 0;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://upload.wikimedia.org/wikipedia/commons/b/b8/Logo_FMBRU.jpg');
            opacity: 0.1;
            background-size: cover;
            background-position: center;
            z-index: -1;
        }

        footer {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 0;
            margin: 0;
            width: 100%;
            position: 0;
            bottom: 0;
        }

        div {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 3rem;
        }

        h4 {
            font-weight: 100;
        }

        p {
            padding: 0.5rem;
            ;
        }

        form {
            background-color: white;
            padding: 1rem;
            margin-left: 5rem;
            margin-right: 18rem;
            border-radius: 7px;
            text-align: left;
            box-shadow: 0 0 10px #1d591f;
        }

        input[type=file] {
            display: block;
            margin-bottom: 20px;
        }

        input[type="submit"] {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }

        table {
            width: 75%;
            border-collapse: collapse;
            border-radius: 5px;
            margin-top: 2rem;
            margin-left: 5rem;
            margin-right: 18rem;
            box-shadow: 0 0 10px #1d591f;
        }

        table,
        th,
        td {
            border: 1px solid #1d591f;
        }

        th,
        td {
            padding: 12px;
            text-align: center;
        }

        th {
            background-color: #4CAF50;
        }
    </style>
</head>

<body>
    <header>
        <h1>Comparação de Respostas</h1>
    </header>
    <main>
        <div>
            <h2>REGRAS:</h2>
            <h3>PARA O FORMS:</h3>
            <p>O formulário google é o que irá gerar o arquivo a ser lido pelo código, portanto, ele precisa estar bem
                padronizado a fim de evitar erros. Seguem algumas dicas para produção do formulário google que devem ser
                seguidas para garantir um bom funcionamento: </p>
            <p style="padding: 30;">1. O forms dos veteranos e bixos devem ser iguais (perguntas escritas iguais, na
                mesma ordem, com
                alternativas iguais), por isso recomenda-se <strong>criar apenas um formulário e duplica-lo</strong>,
                para enviar o original aos veteranos e a cópia aos bixos. <br>
                2. As respostas devem estar no formato <strong>"escala linear"</strong>, para que elas representem
                números que serão posteriormente usados nas contas do pareamento <br>
                3. Precisa haver uma <strong>pergunta "Nome completo"</strong>, pois o código irá usar a resposta dessa
                pergunta para identificação <br>
                4. <strong>Todas as perguntas devem ser obrigatórias.</strong> Para resolver isso, vá para
                configurações, configurações padrão das perguntas e ative a opção mostrada.
            </p>
            <p>Link do forms usado pela T7</p>
            <h3>PARA O ENVIO DO ARQUIVO EXCEL:</h3>
            <p>Para conseguir um arquvio correto com as respostas dos veteranos e bixos, você precisará seguir o
                seguinte passo a passo: <br>
            </p>
            <p>1. Ir para a seção de respostas em seu formulário google e clicar em <strong>"Ver no app
                    Planilhas"</strong> <br>
                2. No google sheets, clicar em <strong>"Arquivo"</strong> na parte de cima da esquerda <br>
                3. Em seguida clicar em <strong>"Baixar"</strong>, e selecionar <strong>"Valores separados por vírgulas
                    (.csv)"</strong> <br>
                4. Pronto, esse é o arquivo que deve ser enviado no campo ao lado, tanto para o formulário dos veteranos
                quanto para o dos bixos <br>
                5. <strong>Se forem necessárias novas rodadas de pareamento deve-se criar um novo forms</strong> (com as
                respostas daqueles que não estão pareados ainda) ou apagar todas as respostas das pessoas já pareadas lá
                no google sheets <br>
            </p>
        </div>
        <div>
            <form id="upload-form">
                <label for="tabela1">Formulários dos veteranos:</label>
                <input type="file" id="tabelaVeteranos" name="tabelaVeteranos" accept=".csv" required>
                <label for="tabela2">Formulários dos bixos:</label>
                <input type="file" id="tabelaBixos" name="tabelaBixos" accept=".csv" required>
                <input type="submit" value="Comparar">
            </form>
            <div id="resultados"></div>
        </div>
        <div>
            <h2>COMO O CÓDIGO FUNCIONA:</h2>
            <p>O código foi feito de modo a realizar o seguinte passo a passo: <br>
                1. Ele recebe o input dos arquivos .csv, garante que ambos foram recebidos e processa suas informações
                pela função parseCSV <br>
                2. Em seguida, usa os valores atribuídos a cada resposta para calcular a distância euclidiana entre duas
                pessoas (isso ocorre com todas as pessoas, ou seja, ele calcula a distancia entre todas as duplas
                possíveis). <br>
                3. Então, pareia as duplas, começando pelas de menor distância (maior afinidade) para as de menor
                distância. <br>
                4. Exibe os resultados numa tabela e fornece um pdf com os pares e as pessoas não pareadas. <br>
            </p>
        </div>
        <main>
        <footer>
            <p> <br> <br> <br> </p>
        </footer>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.14/jspdf.plugin.autotable.min.js"></script>
        <script>
            document.getElementById('upload-form').addEventListener('submit', 
            function (event) {
                event.preventDefault();
                const tabelaVeteranos = document.getElementById('tabelaVeteranos').files[0];
                const tabelaBixos = document.getElementById('tabelaBixos').files[0];
                if (!tabelaVeteranos || !tabelaBixos) {
                    alert("Por favor, selecione ambos os arquivos .csv.");
                     return;
                 }
                //Aqui, usamos Promise.all para garantir que as duas promessas (de parsing dos arquivos CSV) sejam resolvidas antes de prosseguir. Quando ambas as promessas são resolvidas, data1 e data2 contêm os dados dos arquivos CSV.
                Promise.all([parseCSV(tabelaVeteranos), parseCSV(tabelaBixos)])
                     .then(([dataVeteranos, dataBixos]) => {
                         console.log(dataVeteranos);
                        console.log(dataBixos);
                        if (dataVeteranos.length === 0 || dataBixos.length === 0) {
                            alert("Um dos arquivos .csv está vazio ou não pôde ser lido.");
                            return;
                        }
                        //Verificamos se a coluna 'Nome completo' existe em ambos os arquivos CSV. Se não existir, mostramos um alerta e interrompemos a função.
                        if (!dataVeteranos[0].hasOwnProperty('Nome completo') || !dataBixos[0].hasOwnProperty('Nome completo')) {
                            alert("Um dos arquivos .csv não contém a coluna 'Nome completo'.");
                            return;
                        }
                        //Usamos a função compararTabelas para comparar os dados dos dois arquivos CSV, e armazenamos o resultado na variável resultados. Em seguida, exibimos os resultados e salvamos esses resultados em um PDF.
                        const resultados = compararTabelas(dataVeteranos, dataBixos);
                        exibirResultados(resultados);
                        salvarResultadosPDF(resultados, dataVeteranos, dataBixos);
                        //Finalmente, se houver resultados, usamos a função marcarNaoPareados para marcar os dados que não foram pareados.
                        if (resultados.length > 0) {
                            marcarNaoPareados(dataVeteranos, dataBixos, resultados);
                        }
                    });

            });

            //Ela é responsável por ler e processar arquivos CSV usando a biblioteca Papa Parse.
            function parseCSV(file) {
                    return new Promise((resolve, reject) => {
                        Papa.parse(file, {
                            header: true,
                            complete: results => resolve(results.data),
                            error: err => reject(err)
                        });
                    });
                }

            //É acionada pela função compararTabelas para calcular a distância euclidiana entre os participantes
            function calcularDistanciaEuclidiana(respostasVeteranos, respostasBixos) {
                const somaQuadrados = respostasVeteranos.reduce((acc, val, index) => {
                    const diferenca = parseInt(val) - parseInt(respostasBixos[index]);
                    return acc + (diferenca * diferenca);
                }, 0);
                return Math.sqrt(somaQuadrados);
            }

            //Seleciona apenas as colunas que contêm respostas de 1 a 5, em vez de excluir as colunas de nome, número de celular e data/hora.
            function extrairRespostasEscala(pessoa) {
                return Object.keys(pessoa)
                    //Este filtro seleciona apenas as chaves cujos valores estão entre 1 e 5, garantindo que apenas as colunas com respostas de 1 a 5 sejam incluídas.
                    .filter(key => pessoa[key] >= 1 && pessoa[key] <= 5)
                    //Mapeia as chaves filtradas para seus valores correspondentes, retornando um array com as respostas selecionadas.
                    .map(key => pessoa[key]);
            }

            //A função recebe duas tabelas como parâmetros (tabela1 e tabela2) e inicia um array vazio resultados para armazenar os pares e suas distâncias.
            function compararTabelas(tabelaVeteranos, tabelaBixos) {
                    const resultados = [];
                    //Para cada pessoa em tabelaVeteranos que não está marcada como pareada (!pessoa1['Pareado']), a função itera sobre tabela2, buscando também pessoas não pareadas. Extraímos as respostas das duas pessoas usando extrairRespostasEscala. Calculamos a distância euclidiana entre as respostas usando calcularDistanciaEuclidiana.
                    tabelaVeteranos.forEach(pessoaVeterano => {
                        if (!pessoaVeterano['Pareado']) {
                            tabelaBixos.forEach(pessoaBixo => {
                                if (!pessoaBixo['Pareado']) {
                                    //Usa a função extrairRespostasEscala para criar um array com as respostas desejadas (aquelas que serão usadas pela função calcularDistanciaEuclidiana)
                                    const respostasVeteranos = extrairRespostasEscala(pessoaVeterano);
                                    const respostasBixos = extrairRespostasEscala(pessoaBixo);
                                    const distancia = calcularDistanciaEuclidiana(respostasVeteranos, respostasBixos);
                                    //Adicionamos um objeto ao array resultados com as informações das duas pessoas e a distância calculada entre suas respostas.
                                    resultados.push({
                                        pessoaTabelaVeterano: pessoaVeterano['Nome completo'],
                                        telefoneVeterano: String(pessoaVeterano['Numero do celular sem caracter especial']),
                                        pessoaTabela2: pessoaBixo['Nome completo'],
                                        distancia: distancia,
                                        telefoneBixo: String(pessoaBixo['Numero do celular sem caracter especial']),
                                        horarioVeterano: new Date(pessoaVeterano['Carimbo de data/hora']),
                                        horarioBixo: new Date(pessoaBixo['Carimbo de data/hora'])
                                    });
                                }
                            });
                        }
                    });
                    //Ordenamos o array resultados pela distância, do menor para o maior, para encontrar os pares mais próximos.
                    resultados.sort((a, b) => a.distancia - b.distancia);
                    //Iteramos sobre os resultados ordenados e selecionamos os melhores pares, adicionando-os a melhoresResultados e atualizando os conjuntos usadosTabelaVeteranos e usadosTabelaBixos para garantir que as mesmas pessoas não sejam pareadas mais de uma vez.
                    const melhoresResultados = [];
                    const usadosTabelaVeteranos = new Set();
                    const usadosTabelaBixos = new Set();
                    for (const resultado of resultados) {
                        if (!usadosTabelaVeteranos.has(resultado.pessoaTabelaveterano) && !usadosTabelaBixos.has(resultado.pessoaTabelaBixo)) {
                            melhoresResultados.push(resultado);
                            usadosTabelaVeteranos.add(resultado.pessoaTabelaVeterano);
                            usadosTabelaBixos.add(resultado.pessoaTabelaBixo);
                        }
                    }
                    //A função retorna os melhores pares de pessoas com base na menor distância euclidiana entre suas respostas.
                    return melhoresResultados;
                }

            function exibirResultados(resultados) {
                const resultadosDiv = document.getElementById('resultados'); // Seleciona o elemento HTML com id 'resultados'
                resultadosDiv.innerHTML = ''; // Limpa o conteúdo interno do elemento 'resultados'
                if (resultados.length === 0) { // Verifica se não há resultados
                    resultadosDiv.textContent = "Nenhum resultado encontrado."; // Exibe a mensagem "Nenhum resultado encontrado."
                    return; // Sai da função se não houver resultados
                }
                const tabela = document.createElement('table'); // Cria um elemento 'table'
                const thead = document.createElement('thead'); // Cria um elemento 'thead' (cabeçalho da tabela)
                const tbody = document.createElement('tbody'); // Cria um elemento 'tbody' (corpo da tabela)
                const cabecalho = ['Veteranos', 'Bixos', 'Distância', 'Telefone do Veterano', 'Telefone do Bixo']; // Define os títulos das colunas da tabela
                const tr = document.createElement('tr'); // Cria uma linha (tr) para o cabeçalho
                cabecalho.forEach(text => { // Para cada título no cabeçalho...
                    const th = document.createElement('th'); // Cria um elemento 'th' (célula de cabeçalho)
                    th.textContent = text; // Define o texto da célula do cabeçalho
                    tr.appendChild(th); // Adiciona a célula do cabeçalho à linha do cabeçalho
                });
                thead.appendChild(tr); // Adiciona a linha do cabeçalho ao 'thead'
                tabela.appendChild(thead); // Adiciona o 'thead' à tabela
                resultados.forEach(resultado => { // Para cada resultado...
                    const tr = document.createElement('tr'); // Cria uma nova linha para o corpo da tabela
                    ['pessoaTabelaVeterano', 'pessoaTabelaBixo', 'distancia', 'telefoneVeterano', 'telefoneBixo'].forEach(key => { // Para cada chave no resultado...
                        const td = document.createElement('td'); // Cria uma célula (td)
                        if (key === 'distancia') { // Se a chave for 'distancia'...
                            td.textContent = parseFloat(resultado[key]).toFixed(2); // Formata o valor para 2 casas decimais
                        } else {
                            td.textContent = resultado[key] || " "; // Define o texto da célula com o valor correspondente ou um espaço em branco
                        }
                        tr.appendChild(td); // Adiciona a célula à linha
                    });
                    tbody.appendChild(tr); // Adiciona a linha ao 'tbody'
                });
                tabela.appendChild(tbody); // Adiciona o 'tbody' à tabela
                resultadosDiv.appendChild(tabela); // Adiciona a tabela ao elemento 'resultados'
            }

            //essa função serve para identificar e marcar as pessoas que não foram pareadas nos resultados
            function marcarNaoPareados(tabelaVeteranos, tabelaBixos, resultados) {
                tabelaVeteranos.forEach(pessoa => { // Para cada pessoa na tabelaVeteranos...
                    if (!resultados.some(r => r.pessoaTabelaVeterano === pessoa['Nome completo'])) { // Verifica se não há resultado em que 'pessoaTabelaVeterano' seja igual ao 'Nome completo' da pessoa
                        pessoa['Pareado'] = 'Nao'; // Se não houver, marca a pessoa como 'Nao Pareado'
                    }
                });
                tabelaBixos.forEach(pessoa => { // Para cada pessoa na tabelaBixos...
                    if (!resultados.some(r => r.pessoaTabelaBixo === pessoa['Nome completo'])) { // Verifica se não há resultado em que 'pessoaTabelaBixo' seja igual ao 'Nome completo' da pessoa
                        pessoa['Pareado'] = 'Nao'; // Se não houver, marca a pessoa como 'Nao Pareado'
                    }
                });
            }

            //
            function salvarResultadosPDF(resultados, tabelaVeteranos, tabelaBixos) {
                const { jsPDF } = window.jspdf; // Importa o módulo jsPDF da biblioteca window.jspdf
                const doc = new jsPDF(); // Cria um novo documento PDF

                const dadosTabela = resultados.map(resultado => [
                    resultado.pessoaTabelaVeterano, // Adiciona o nome da pessoa da tabela1
                    resultado.pessoaTabelaBixo, // Adiciona o nome da pessoa da tabela2
                    resultado.distancia.toFixed(2), // Adiciona a distância formatada para 2 casas decimais
                    resultado.telefoneVeterano, // Adiciona o telefone do veterano
                    resultado.telefoneBixo // Adiciona o telefone do bixo
                ]);

                doc.autoTable({
                    head: [['Veteranos', 'Bixos', 'Distância', 'Telefone do Veterano', 'Telefone do Bixo']], // Cabeçalho da tabela
                    body: dadosTabela, // Corpo da tabela
                    theme: 'striped', // Tema listrado
                    headStyles: { fillColor: [34, 139, 34], textColor: [255, 255, 255] }, // Estilos do cabeçalho
                    styles: { fillColor: false, textColor: [0, 0, 0] } // Estilos das células
                });

                const naoPareadosTabelaVeteranos = tabelaVeteranos.filter(p => !resultados.some(r => r.pessoaTabelaveterano === p['Nome completo'])).map(p => [p['Nome completo'], 'Veterano']);
                // Filtra as pessoas da tabela1 que não estão nos resultados e cria um array de pessoas não pareadas
                const naoPareadosTabelaBixos = tabelaBixos.filter(p => !resultados.some(r => r.pessoaTabelaBixo === p['Nome completo'])).map(p => [p['Nome completo'], 'Bixo']);
                // Filtra as pessoas da tabela2 que não estão nos resultados e cria um array de pessoas não pareadas

                if (naoPareadosTabelaVeteranos.length > 0 || naoPareadosTabelaBixos.length > 0) { // Verifica se há pessoas não pareadas
                    doc.autoTable({
                        head: [['Nome completo - Não Pareados', 'Categoria']], // Cabeçalho da tabela de não pareados
                        body: [...naoPareadosTabelaVeteranos, ...naoPareadosTabelaBixos], // Corpo da tabela de não pareados
                        startY: doc.autoTable.previous.finalY + 10, // Define a posição inicial da nova tabela abaixo da tabela anterior
                        theme: 'striped', // Tema listrado
                        headStyles: { fillColor: [231, 76, 60], textColor: [255, 255, 255] }, // Estilos do cabeçalho
                        styles: { fillColor: false, textColor: [0, 0, 0] } // Estilos das células
                    });
                }

                doc.save('resultados_pareamento.pdf'); // Salva o documento PDF com o nome 'resultados_pareamento.pdf'
            }

        </script>
</body>

</html>